<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Just One Single History</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="usecases.html"><strong aria-hidden="true">2.</strong> Use cases</a></li><li class="chapter-item expanded affix "><li class="part-title">Guide</li><li class="chapter-item expanded "><a href="guide/gettingstarted.html"><strong aria-hidden="true">3.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="guide/workspaces.html"><strong aria-hidden="true">4.</strong> Working with workspaces</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Importing projects</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Integrating with CI</div></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/filters.html"><strong aria-hidden="true">7.</strong> Filter syntax</a></li><li class="chapter-item expanded "><a href="reference/proxy.html"><strong aria-hidden="true">8.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="reference/workspace.html"><strong aria-hidden="true">9.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">10.</strong> Command line tools</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Graphql API</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Handlebar generator</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> The josh UI</div></li><li class="chapter-item expanded affix "><li class="part-title">Contributing</li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Development tools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Tracing</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Just One Single History</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="../banner.png" alt="Just One Single History" /></p>
<p>Josh combines the advantages of monorepos with those of multirepos by leveraging a blazingly-fast,
incremental, and reversible implementation of git history filtering.</p>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<p>Traditionally, history filtering has been viewed as an expensive operation that should only be
performed to fix issues with a repository, such as purging big binary files or removing
accidentally-committed secrets, or as part of a migration to a different repository structure, like
switching from multirepo to monorepo (or vice versa).</p>
<p>The implementation shipped with git (<code>git-filter branch</code>) is only usable as a once-in-a-lifetime
last resort for anything but tiny repositories.</p>
<p>Faster versions of history filtering have been implemented, such as
<a href="https://github.com/newren/git-filter-repo">git-filter-repo</a> or the
<a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG repo cleaner</a>. Those, while much faster, are
designed for doing occasional, destructive maintenance tasks, usually with the idea already in mind
that once the filtering is complete the old history should be discarded.</p>
<p>The idea behind <code>josh</code> started with two questions:</p>
<ol>
<li>What if history filtering could be so fast that it can be part of a normal, everyday workflow,
running on every single push and fetch without the user even noticing?</li>
<li>What if history filtering was a non-destructive, reversible operation?</li>
</ol>
<p>Under those two premises a filter operation stops being a maintenance task. It seamlessly relates
histories between repos, which can be used by developers and CI systems interchangeably in whatever
way is most suitable to the task at hand.</p>
<p>How is this possible?</p>
<p>Filtering history is a highly predictable task: The set of filters that tend to be used for any
given repository is limited, such that the input to the filter (a git branch) only gets modified in
an incremental way. Thus, by keeping a persistent cache between filter runs, the work needed to
re-run a filter on a new commit (and its history) becomes proportional to the number of changes
since the last run; The work to filter no longer depends on the total length of the history.
Additionally, most filters also do not depend on the size of the trees.</p>
<p>What has long been known to be true for performing merges also applies to history filtering: The
more often it is done the less work it takes each time.</p>
<p>To guarantee filters are reversible we have to restrict the kind of filter that can be used; It is
not possible to write arbitrary filters using a scripting language like is allowed in other tools.
To still be able to cover a wide range of use cases we have introduced a domain-specific language to
express more complex filters as a combination of simpler ones. Apart from guaranteeing
reversibility, the use of a DSL also enables pre-optimization of filter expressions to minimize both
the amount of work to be done to execute the filter as well as the on-disk size of the persistent
cache.</p>
<blockquote>
<p><em><em>From Linus Torvalds 2007 talk at Google about git:</em></em></p>
<p><strong>Audience:</strong></p>
<p>Can you have just a part of files pulled out of a repository, not the entire repository?</p>
<p><strong>Linus:</strong></p>
<p>You can export things as tarballs, you can export things as individual files, you can rewrite the
whole history to say &quot;I want a new version of that repository that only contains that part&quot;, you
can do that, it is a fairly expensive operation it's something you would do for example when you
import an old repository into a one huge git repository and then you can split it later on to be
multiple smaller ones, you can do it, what I am trying to say is that you should generally try to
avoid it. It's not that git can not handle huge projects, git would not perform as well as it would
otherwise. And you will have issues that you wish you didn't not have.</p>
<p>So I am skipping this issue and going back to the performance issue. One of the things I want to
say about performance is that a lot of people seem to think that performance is about doing the
same thing, just doing it faster, and that is not true.</p>
<p>That is not what performance is all about. If you can do something really fast, really well, people
will start using it differently.</p>
</blockquote>
<h1 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h1>
<h3 id="partial-cloning"><a class="header" href="#partial-cloning">Partial cloning</a></h3>
<p>Reduce scope and size of clones by treating subdirectories of the monorepo
as individual repositories.</p>
<pre><code>$ git clone http://josh/monorepo.git:/path/to/library.git
</code></pre>
<p>The partial repo will act as a normal git repository but only contain the files
found in the subdirectory and only commits affecting those files.
The partial repo supports both fetch as well as push operation.</p>
<p>This helps not just to improve performace on the client due to having fever files in
the tree,
it also enables collaboration on parts of the monorepo with other parties
utilizing git's normal distributed development features.
For example, this makes it easy to mirror just selected parts of your
repo to public github repositories or specific customers.</p>
<h3 id="project-composition--workspaces"><a class="header" href="#project-composition--workspaces">Project composition / Workspaces</a></h3>
<p>Simplify code sharing and dependency management. Beyond just subdirectories,
Josh supports filtering, re-mapping and composition of arbitrary virtual repositories
from the content found in the monorepo.</p>
<p>The mapping itself is also stored in the repository and therefore versioned alongside
the code.</p>
<p>Multiple projects, depending on a shared set of libraries, can thus live together in a single repository.
This approach is commonly referred to as “monorepo”, and was popularized by
<a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">Google</a>, Facebook or Twitter to name a
few.</p>
<p>In this example, two projects (<code>project1</code> and <code>project2</code>) coexist in the <code>central</code> monorepo.</p>
<table>
    <thead>
        <tr>
            <th>Central monorepo</th>
            <th>Project workspaces</th>
            <th>workspace.josh file</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=2><img src="./img/central.svg?sanitize=true" alt="Folders and files in central.git" /></td>
            <td><img src="./img/project1.svg?sanitize=true" alt="Folders and files in project1.git" /></td>
            <td>
<pre>
dependencies = :/modules:[
    ::tools/
    ::library1/
]
</pre>
        </tr>
        <tr>
            <td><img src="./img/project2.svg?sanitize=true" alt="Folders and files in project2.git" /></td>
            <td>
<pre>libs/library1 = :/modules/library1</pre></td>
        </tr>
    </tbody>
</table>
<p>Workspaces act as normal git repos:</p>
<pre><code>$ git clone http://josh/central.git:workspace=workspaces/project1.git
</code></pre>
<p>Each of the subprojects defines a <code>workspace.josh</code> file, defining the mapping between the original central.git repository and the hierarchy in use inside of the project.</p>
<p>In this setup, project1 and project2 can seemlessly depend on the latest version of library1, while only checking out the part of the central monorepo that's needed for their purpose.
What's more, any changes to a shared module will be synced in both directions.</p>
<p>If a developper of the library1 pushed a new update, both projects will get the new version, and the developper will be able to check if they broke any test.
If a developper of project1 needs to update the library, the changes will be automatically shared back into central, and project2.</p>
<h3 id="simplified-cicd"><a class="header" href="#simplified-cicd">Simplified CI/CD</a></h3>
<p>With everything stored in one repo, CI/CD systems only need to look into one source for each particular
deliverable.
However in traditional monorepo environments dependency mangement is handled by the build system.
Build systems are usually taylored to specific languages and need their input already checked
out on the filesystem.
So the question:</p>
<blockquote>
<p>&quot;What deliverables are affected by a given commit and need to be rebuild?&quot;</p>
</blockquote>
<p>cannot be answered without cloning the entire repository and understanding how the languages
used handle dependencies.</p>
<p>In particular when using C familiy languages, hidden dependencies on header files are easy to miss.
For this reason limiting the visibility of files to the compiler by sandboxing is pretty much a requirement
for reproducible builds.</p>
<p>With Josh, each deliverable gets it's own virtual git repository with dependencies declared in the <code>workspace.josh</code>
file. This means answering the above question becomes as simple as comparing commit ids.
Furthermore due to the tree filtering each build is guaranteed to be perfectly sandboxed
and only sees those parts of the monorepo that have actually been mapped.</p>
<p>This also means the deliverables to be re-built can be determined without cloning any repos like
typically necessary with normal build tools.</p>
<h3 id="graphql-api"><a class="header" href="#graphql-api">GraphQL API</a></h3>
<p>It is often desireable to access content stored in git without requiring a clone of the repository.
This is usefull for CI/CD systems or web frontends such as dashboards.</p>
<p>Josh exposes a GraphQL API for that purpose. For example, it can be used to find all workspaces currently
present in the tree:</p>
<pre><code>query {
  rev(at:&quot;refs/heads/master&quot;, filter:&quot;::**/workspace.josh&quot;) {
    files { path }
  }
}
</code></pre>
<h3 id="caching-proxy"><a class="header" href="#caching-proxy">Caching proxy</a></h3>
<p>Even without using the more advanced features like partial cloning or workspaces,
<code>josh-proxy</code> can act as a cache to reduce traffic between locations or keep your CI from
performing many requests to the main git host.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This book will guide you into setting up the josh
proxy to serve your own git repository.</p>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>All the commands are included from the file <code>gettingstarted.t</code>
which can be run with <a href="https://bitheap.org/cram/">cram</a>.</p>
</blockquote>
<h2 id="setting-up-the-proxy"><a class="header" href="#setting-up-the-proxy">Setting up the proxy</a></h2>
<p>Josh is distributed via <a href="https://hub.docker.com/r/esrlabs/josh-proxy">docker hub</a>,
and is installed and started with the following command:</p>
<pre><code class="language-shell">  $ docker run -d -p 8000:8000 -e JOSH_REMOTE=https://github.com -v josh-vol:$(pwd)/git_data esrlabs/josh-proxy:latest &gt; josh.out
</code></pre>
<p>This starts josh as a proxy to github.com, in a docker container, 
mounting the ./git_data folder to the image for use by josh.</p>
<h2 id="cloning-a-repository"><a class="header" href="#cloning-a-repository">Cloning a repository</a></h2>
<p>Once josh is running, we can clone a repository through it.
For example, let's clone josh:</p>
<pre><code class="language-shell">  $ git clone http://localhost:8000/esrlabs/josh.git
  Cloning into 'josh'...
  $ cd josh
</code></pre>
<p>As we can see, this repository is simply the normal josh one:</p>
<pre><code class="language-shell">  $ ls
  Cargo.lock
  Cargo.toml
  Dockerfile
  Dockerfile.tests
  LICENSE
  Makefile
  README.md
  docs
  josh-proxy
  run-josh.sh
  run-tests.sh
  rustfmt.toml
  scripts
  src
  static
  tests
  $ git log -2
  commit fc6af1e10c865f790bff7135d02b1fa82ddebe29
  Author: Christian Schilling &lt;christian.schilling@esrlabs.com&gt;
  Date:   Fri Mar 19 11:15:57 2021 +0100
  
      Update release.yml
  
  commit 975581064fa21b3a3d6871a4e888fd6dc1129a13
  Author: Christian Schilling &lt;christian.schilling@esrlabs.com&gt;
  Date:   Fri Mar 19 11:11:45 2021 +0100
  
      Update release.yml
</code></pre>
<h2 id="extracting-a-module"><a class="header" href="#extracting-a-module">Extracting a module</a></h2>
<p>Josh becomes interesting when we want to extract a module.
Let's check out the josh repository again, but this time let's filter
only the documentation out:</p>
<pre><code class="language-shell">  $ cd ..
  $ git clone http://localhost:8000/esrlabs/josh.git:/docs.git
  Cloning into 'docs'...
  $ cd docs
</code></pre>
<p>Note the addition of <code>:/docs</code> at the end of the url.
This is called a filter, and it instructs josh to only check out the
given folder.</p>
<p>Looking inside the repository, we now see that the history is quite
different. Indeed, it contains only the commits pertaining to the 
subfolder that we checked out.</p>
<pre><code class="language-shell">  $ ls
  book.toml
  src
  $ git log -2
  commit dd26c506f6d6a218903b9f42a4869184fbbeb940
  Author: Christian Schilling &lt;christian.schilling@esrlabs.com&gt;
  Date:   Mon Mar 8 09:22:21 2021 +0100
  
      Update docs to use docker for default setup
  
  commit ee6abba0fed9b99c9426f5224ff93cfee2813edc
  Author: Louis-Marie Givel &lt;louis-marie.givel@esrlabs.com&gt;
  Date:   Fri Feb 26 11:41:37 2021 +0100
  
      Update proxy.md
</code></pre>
<p>This repository is a real repository in which we can pull, commit, push,
as with a regular one. Josh will take care of synchronizing it with
the main one in a transparent fashion.</p>
<h1 id="working-with-workspaces"><a class="header" href="#working-with-workspaces">Working with workspaces</a></h1>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>All the commands are included from the file <code>workspaces.t</code>
which can be run with <a href="https://bitheap.org/cram/">cram</a>.</p>
</blockquote>
<p>Josh really starts to shine when using workspaces.</p>
<p>Simply put, they are a list of files and folders, remapped from the central repository
to a new repository.
For example, a shared library could be used by various workspaces, each mapping it to
their appropriate subdirectory.</p>
<p>In this chapter, we're going to set up a new git repository with a couple of libraries,
and then use it to demonstrate the use of workspaces.</p>
<h2 id="test-set-up"><a class="header" href="#test-set-up">Test set-up</a></h2>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>The following section describes how to set-up a local git server with made-up content
for the sake of this tutorial.
You're free to follow it, or to use your own existing repository, in which case you
can skip to the next section</p>
</blockquote>
<p>To host the repository for this test, we need a git server.
We're going to run git as a <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">cgi</a>
program using its provided http backend, served with the test server included in
the <a href="https://crates.io/crates/hyper_cgi">hyper_cgi</a> crate.</p>
<h3 id="serving-the-git-repo"><a class="header" href="#serving-the-git-repo">Serving the git repo</a></h3>
<p>First, we create a <em>bare</em> repository, which will be served by hyper_cgi. We enable
the option <code>http.receivepack</code> to allow the use of <code>git push</code> from the clients.</p>
<pre><code class="language-shell">  $ git init --bare ./remote/real_repo.git/
  Initialized empty Git repository in */real_repo.git/ (glob)
  $ git config -f ./remote/real_repo.git/config http.receivepack true
</code></pre>
<p>Then we start the server which will allow clients to access the repository through
http.</p>
<pre><code class="language-shell">  $ GIT_DIR=./remote/ GIT_PROJECT_ROOT=${TESTTMP}/remote/ GIT_HTTP_EXPORT_ALL=1 hyper-cgi-test-server\
  &gt;  --port=8001\
  &gt;  --dir=./remote/\
  &gt;  --cmd=git\
  &gt;  --args=http-backend\
  &gt;  &gt; ./hyper-cgi-test-server.out 2&gt;&amp;1 &amp;
  $ echo $! &gt; ./server_pid
</code></pre>
<p>Our server is ready, serving all the repos in the <code>remote</code> folder on port <code>8001</code>.</p>
<pre><code class="language-shell">  $ git clone http://localhost:8001/real_repo.git
  Cloning into 'real_repo'...
  warning: You appear to have cloned an empty repository.
</code></pre>
<h3 id="adding-some-content"><a class="header" href="#adding-some-content">Adding some content</a></h3>
<p>Of course, the repository is for now empty, and we need to populate it.
The <a href="guide/populate.sh">populate.sh</a> script creates a couple of libraries, as well as two applications that use
them.</p>
<pre><code class="language-shell">  $ cd real_repo
  $ sh ${TESTDIR}/populate.sh &gt; ../populate.out

  $ git push origin HEAD
  To http://localhost:8001/real_repo.git
   * [new branch]      HEAD -&gt; master

  $ tree
  .
  |-- application1
  |   `-- app.c
  |-- application2
  |   `-- guide.c
  |-- doc
  |   |-- guide.md
  |   |-- library1.md
  |   `-- library2.md
  |-- library1
  |   `-- lib1.h
  `-- library2
      `-- lib2.h
  
  5 directories, 7 files
  $ git log --oneline --graph
  * f65e94b Add documentation
  * f240612 Add application2
  * 0a7f473 Add library2
  * 1079ef1 Add application1
  * 6476861 Add library1
</code></pre>
<h2 id="creating-our-first-workspace"><a class="header" href="#creating-our-first-workspace">Creating our first workspace</a></h2>
<p>Now that we have a git repo populated with content, let's serve it through josh:</p>
<pre><code class="language-shell">  $ docker run -d --network=&quot;host&quot; -e JOSH_REMOTE=http://127.0.0.1:8001 -v josh-vol:$(pwd)/git_data esrlabs/josh-proxy:latest &gt; josh.out
</code></pre>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>For the sake of this example, we run docker with --network=&quot;host&quot; instead of publishing the port.
This is so that docker can access localhost, where our ad-hoc git repository is served.</p>
</blockquote>
<p>To facilitate developement on applications 1 and 2, we want to create workspaces for them.
Creating a new workspace looks very similar to checking out a subfolder through josh, as explain
in &quot;Getting Started&quot;.</p>
<p>Instead of just the name of the subfolder, though, we also use the <code>:workspace=</code> filter:</p>
<pre><code class="language-shell">  $ git clone http://127.0.0.1:8000/real_repo.git:workspace=application1.git application1
  Cloning into 'application1'...
  $ cd application1
  $ tree
  .
  `-- app.c
  
  0 directories, 1 file
  $ git log -2
  commit 50cd6112e173df4cac1aca9cb88b5c2a180bc526
  Author: Josh &lt;josh@example.com&gt;
  Date:   Thu Apr 7 22:13:13 2005 +0000
  
      Add application1
</code></pre>
<p>Looking into the newly cloned workspace, we see our expected files and the history containing the
only relevant commit.</p>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>Josh allows us to create a workspace out of any directory, even one that doesn't exist yet.</p>
</blockquote>
<h3 id="adding-workspacejosh"><a class="header" href="#adding-workspacejosh">Adding workspace.josh</a></h3>
<p>The workspace.josh file describes how folders from the central repository (real_repo.git)
should be mapped to the workspace repository.</p>
<p>Since we depend on library1, let's add it to the workspace file.</p>
<pre><code class="language-shell">  $ echo &quot;modules/lib1 = :/library1&quot; &gt;&gt; workspace.josh

  $ git add workspace.josh

  $ git commit -m &quot;Map library1 to the application1 workspace&quot;
  [master 06361ee] Map library1 to the application1 workspace
   1 file changed, 1 insertion(+)
   create mode 100644 workspace.josh
</code></pre>
<p>We decided to map library1 to modules/lib1 in the workspace.
We can now sync up with the server, and observe the result</p>
<pre><code class="language-shell">  $ git sync origin HEAD
    HEAD -&gt; refs/heads/master
  From http://127.0.0.1:8000/real_repo.git:workspace=application1
   * branch            753d62ca1af960a3d071bb3b40722471228abbf6 -&gt; FETCH_HEAD
  HEAD is now at 753d62c Map library1 to the application1 workspace
  Pushing to http://127.0.0.1:8000/real_repo.git:workspace=application1.git
  POST git-receive-pack (477 bytes)
  remote: josh-proxy        
  remote: response from upstream:        
  remote: To http://127.0.0.1:8001/real_repo.git        
  remote:    f65e94b..37184cc  JOSH_PUSH -&gt; master        
  remote: REWRITE(06361eedf6d6f6d7ada6000481a47363b0f0c3de -&gt; 753d62ca1af960a3d071bb3b40722471228abbf6)        
  remote: 
  remote: 
  updating local tracking ref 'refs/remotes/origin/master'
  
  $ tree
  .
  |-- app.c
  |-- modules
  |   `-- lib1
  |       `-- lib1.h
  `-- workspace.josh
  
  2 directories, 3 files
  $ git log --graph --oneline
  *   753d62c Map library1 to the application1 workspace
  |\  
  | * 366adba Add library1
  * 50cd611 Add application1
</code></pre>
<p>After pushing and fetching the result, we se that it has been succesfully mapped by josh.</p>
<p>One suprising thing is the history: our &quot;mapping&quot; commit became a merge commit!
This is because josh needs to merge the history of the module we want to map into the
repository of the workspace.
After this is done, all commit will be present in both of the histories.</p>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p><code>git sync</code> is a utility provided with josh which will push contents, and, if josh tells
it to, fetch the transformed result. Otherwise, it works like git push.</p>
</blockquote>
<p>By the way, what does the history look like on the real_repo ?</p>
<pre><code class="language-shell">  $ cd ../real_repo
  $ git pull origin master
  From http://localhost:8001/real_repo
   * branch            master     -&gt; FETCH_HEAD
     f65e94b..37184cc  master     -&gt; origin/master
  Updating f65e94b..37184cc
  Fast-forward
   application1/workspace.josh | 1 +
   1 file changed, 1 insertion(+)
   create mode 100644 application1/workspace.josh
  Current branch master is up to date.

  $ tree
  .
  |-- application1
  |   |-- app.c
  |   `-- workspace.josh
  |-- application2
  |   `-- guide.c
  |-- doc
  |   |-- guide.md
  |   |-- library1.md
  |   `-- library2.md
  |-- library1
  |   `-- lib1.h
  `-- library2
      `-- lib2.h
  
  5 directories, 8 files
  $ git log --graph --oneline
  * 37184cc Map library1 to the application1 workspace
  * f65e94b Add documentation
  * f240612 Add application2
  * 0a7f473 Add library2
  * 1079ef1 Add application1
  * 6476861 Add library1

</code></pre>
<p>We can see the newly added commit for workspace.josh in application1, and as expected,
no merge here.</p>
<h1 id="history-filtering"><a class="header" href="#history-filtering">History filtering</a></h1>
<p>Josh transforms commits by applying filters to them. As any
commit in git represents not just a single state of the filesystem but also its entire
history, applying a filter to a commit produces an entirely new history.
The result of a filter is a normal git commit and therefore can be filtered again,
making filters chainable.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Filters always begin with a colon and can be chained:</p>
<pre><code>:filter1:filter2
</code></pre>
<p>When used as part of an URL filters can not contain whitespace or newlines. When read from a file
however whitespace can be inserted between filters (not after the leading colon).
Additionally newlines can be used instead of <code>,</code> inside of composition filters.</p>
<h2 id="available-filters"><a class="header" href="#available-filters">Available filters</a></h2>
<h3 id="subdirectory-a"><a class="header" href="#subdirectory-a">Subdirectory <strong><code>:/a</code></strong></a></h3>
<p>Take only the selected subdirectory from the input and make it the root
of the filtered tree.
Note that <code>:/a/b</code> and <code>:/a:/b</code> are equivalent ways to get the same result.</p>
<h3 id="directory-a"><a class="header" href="#directory-a">Directory <strong><code>::a/</code></strong></a></h3>
<p>A shorthand for the commonly occuring filter combination <code>:/a:prefix=a</code>.</p>
<h3 id="file-a"><a class="header" href="#file-a">File <strong><code>::a</code></strong></a></h3>
<p>Produces a tree with only the specified file in it's root.
Note that <code>::a/b</code> is equivalent to <code>::a/::b</code>.</p>
<h3 id="prefix-prefixa"><a class="header" href="#prefix-prefixa">Prefix <strong><code>:prefix=a</code></strong></a></h3>
<p>Take the input tree and place it into subdirectory <code>a</code>.
Note that <code>:prefix=a/b</code> and <code>:prefix=b:prefix=a</code> are equivalent.</p>
<h3 id="composition-filter1filter2filtern"><a class="header" href="#composition-filter1filter2filtern">Composition <strong><code>:[:filter1,:filter2,...,:filterN]</code></strong></a></h3>
<p>Compose a tree by overlaying the outputs of <code>:filter1</code> ... <code>:filterN</code> on top of each other.
It is guaranteed that each file will only appear at most once in the output. The first filter
that consumes a file is the one deciding it's mapped location. Therefore the order in which
filters are composed matters.</p>
<p>Inside of a composition <code>x=:filter</code> can be used as an alternative spelling for
<code>:filter:prefix=x</code>.</p>
<h3 id="exclusion-excludefilter"><a class="header" href="#exclusion-excludefilter">Exclusion <strong><code>:exclude[:filter]</code></strong></a></h3>
<p>Remove all paths matching <code>:filter</code> from the input tree.</p>
<h3 id="workspace-workspacea"><a class="header" href="#workspace-workspacea">Workspace <strong><code>:workspace=a</code></strong></a></h3>
<p>Similar to <code>:/a</code> but also looks for a <code>workspace.josh</code> file inside the
specified directory (called the &quot;workspace root&quot;).
The resulting tree will contain the contents of the
workspace root as well as additional files specifed in the <code>workspace.josh</code> file.
(see <a href="reference/./workspace.html">Workspaces</a>)</p>
<!--
## Pattern filters

The following filters accept a glob like pattern ``X`` that can contain ``*`` to
match any number of characters. Note that two or more consecutive wildcards (``**``) are not
allowed.

### Match directories **`::X/`**
All matching subdirectories in the input root

### Match files **`::X`**
All matching files in the input root

### Match nested directories **`::**/X/`**
All subdirectories matching the pattern in arbitarily deep subdirectories of the input

### Match nested files **`::**/X`**
All files matching the pattern in arbitarily deep subdirectories of the input
-->
<h2 id="filter-order-matters"><a class="header" href="#filter-order-matters">Filter order matters</a></h2>
<p>Filters are applied in the left-to-right order they are given in the filter specification,
and they are <code>not</code> commutative.</p>
<p>For example, this command will filter out just the josh documentation, and store it in a
ref named <code>FILTERED_HEAD</code>:</p>
<pre><code>$ josh-filter :/docs:prefix=josh-docs
</code></pre>
<p>However, <code>this</code> command will produce an empty branch:</p>
<pre><code>$ josh-filter :prefix=josh-docs:/docs
</code></pre>
<p>What's happening in the latter command is that because the prefix filter is applied first, the
entire <code>josh</code> history already lives within the <code>josh-docs</code> directory, as it was just
transformed to exist there. Thus, to still get the docs, the command would need to be:</p>
<pre><code>$ josh-filter :prefix=josh-docs:/josh-docs/docs
</code></pre>
<p>which will contain the josh documentation at the base of the tree. We've lost the prefix, what
gives?? Because the original git tree was already transformed, and then the subdirectory filter
was applied to pull documentation from <code>josh-docs/docs</code>, the prefix is gone - it was filtered out
again by the subdirectory filter. Thus, the order in which filters are provided is crucial, as each
filter further transforms the latest transformation of the tree.</p>
<h1 id="josh-proxy"><a class="header" href="#josh-proxy">josh-proxy</a></h1>
<p>Josh provides an HTTP proxy server that can be used with any git hosting service which communicates
via HTTP.</p>
<p>It needs the URL of the upstream server and a local directory to store its data.
Optionally, a port to listen on can be specified. For example, running a local <code>josh-proxy</code>
instance for github.com on port 8000:</p>
<pre><code>$ docker run -p 8000:8000 -e JOSH_REMOTE=https://github.com -v josh-vol:/data/git esrlabs/josh-proxy:r21.03.08
</code></pre>
<p>For a first example of how to make use of josh, just the josh documentation can be checked out as
its own repository via this command:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs.git
</code></pre>
<blockquote>
<p><strong>Note</strong>: This URL needs to contain the <code>.git</code> suffix twice: once after the original path
and once more after the filter spec.</p>
</blockquote>
<p><code>josh-proxy</code> supports read and write access to the repository, so when making changes
to any files in the filtered repository, you can just commit and push them
like you are used to.</p>
<h2 id="url-syntax-and-breakdown"><a class="header" href="#url-syntax-and-breakdown">URL syntax and breakdown</a></h2>
<p>This is the URL of a <code>josh-proxy</code> instance:</p>
<pre><code>http://localhost:8000
</code></pre>
<p>This is the repository location on the upstream host on which to perform the filter operations:</p>
<pre><code>/esrlabs/josh.git
</code></pre>
<p>This is the set of filter operations to perform:</p>
<pre><code>:/docs.git
</code></pre>
<p>Much more information on the available filters and the syntax of all filters is covered in detail in
the <a href="reference/./filters.html">filters</a> section.</p>
<h2 id="repository-naming"><a class="header" href="#repository-naming">Repository naming</a></h2>
<p>By default, a git URL is used to point to the remote repository to download <em>and also</em> to dictate
how the local repository shall be named.  It's important to learn that the last name in the URL is
what the local git client will name the new, local repository. For example:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs.git
</code></pre>
<p>will create the new repository at directory <code>docs</code>, as <code>docs.git</code> is the last name in the URL.</p>
<p>By default, this leads to rather odd-looking repositories when the <code>prefix</code> filter is the final
filter of a URL:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs:prefix=josh-docs.git
</code></pre>
<p>This will still clone just the josh documentation, but the final directory structure will look like
this:</p>
<pre><code>- prefix=josh-docs
  - josh-docs
    - &lt;docs&gt;
</code></pre>
<p>Having the root repository directory name be the fully-specified filter is most likely not what was
intended. This results from git's reuse and repurposing of the remote URL, as <code>prefix=josh-docs</code>
is the final name in the URL. With no other alternatives, this gets used for the repository name.</p>
<p>To explicitly specify a repository name, provide the desired name after the URL when cloning a new
repository:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs:prefix=josh-docs.git my-repo
</code></pre>
<h1 id="working-with-workspaces-1"><a class="header" href="#working-with-workspaces-1">Working with workspaces</a></h1>
<p>For the sake of this example we will assume a <code>josh-proxy</code> instance is running and serving a
repo on <code>http://josh/world.git</code> with some shared code in <code>shared</code>.</p>
<h2 id="create-a-new-workspace"><a class="header" href="#create-a-new-workspace">Create a new workspace</a></h2>
<p>To create a new workspace in the path <code>ws/hello</code> simply clone it as if it already exists:</p>
<pre><code>$ git clone http://josh/world.git:workspace=ws/hello.git
</code></pre>
<p><code>git</code> will report that you appear to have cloned an empty repository if that path does not
yet exist.
If you don't get this message it means that the path already exists in the repo but may
not yet have configured any path mappings.</p>
<p>The next step is to add some path mapping to the <code>workspace.josh</code> file in the root of the
workspace:</p>
<pre><code>$ cd hello
$ echo &quot;mod/a = :/shared/a&quot; &gt; workspace.josh
</code></pre>
<p>And and commit the changes:</p>
<pre><code>$ git add workspace.josh
$ git commit -m &quot;add workspace&quot;
</code></pre>
<p>If the path did not exist previously, the resulting commit will be a root commit that does not share
any history with the <code>world.git</code> repo.
This means a normal <code>git push</code> will be rejected at this point.
To get correct history, the
resulting commit needs to be a based on the history that already exists in <code>world.git</code>.
There is however no way to do this locally, because we don't have the data required for this.
Also, the resulting tree should contain the contents of <code>shared/a</code> mapped to <code>mod/a</code> which
means it needs to be produced on the server side because we don't have the files to put there.</p>
<p>To accomplish that push with the create option:</p>
<pre><code>$ git push -o create origin master
</code></pre>
<blockquote>
<p><strong>Note</strong>: While it is perfectly possible to use Josh without a code review system,
it is strongly recommended to use some form of code review to be able to inspect commits
created by Josh before they get into the immutable history of your main repository.</p>
</blockquote>
<p>As the resulting commit is created on the server side we need to get it from the server:</p>
<pre><code>$ git pull --rebase
</code></pre>
<p>Now you should see <code>mod/a</code> populated with the content of the shared code.</p>
<h2 id="map-a-shared-path-into-a-workspace"><a class="header" href="#map-a-shared-path-into-a-workspace">Map a shared path into a workspace</a></h2>
<p>To add shared path to a location in the workspace that does not exist yet, first add an
entry to the <code>workspace.josh</code> file and commit that.</p>
<p>At this point the path is of course empty to the commit needs to be pushed to the server.
When the same commit is then fetched back it will have the mapped path populated with the
shared content.</p>
<h2 id="publish-a-non-shared-path-into-a-shared-location"><a class="header" href="#publish-a-non-shared-path-into-a-shared-location">Publish a non-shared path into a shared location</a></h2>
<p>The steps here are exactly the same as for the mapping example above. The only difference being
that the path already exists in the workspace but not in the shared location.</p>
<h2 id="remove-a-mapping"><a class="header" href="#remove-a-mapping">Remove a mapping</a></h2>
<p>To remove a mapping remove the corresponding entry from the <code>workspace.josh</code> file.
The content of the previously shared path will stay in the workspace. That means the main
repo will have two copies of that path from that point on. Effectivly creating a fork of that code.</p>
<h2 id="remove-a-mapped-path"><a class="header" href="#remove-a-mapped-path">Remove a mapped path</a></h2>
<p>To remove a mapped path as well as it's contents, remove the entry from the
<code>workspace.josh</code> file and also remove the path inside the workspace using <code>git rm</code>.</p>
<h1 id="josh-filter"><a class="header" href="#josh-filter">josh-filter</a></h1>
<p>Command to rewrite history using <code>josh</code> filter specs.
By default it will use <code>HEAD</code> as input and update <code>FILTERED_HEAD</code> with the filtered
history, taking a filter specification as argument.</p>
<h1 id="git-sync"><a class="header" href="#git-sync">git-sync</a></h1>
<p>A utility to make working with server side rewritten commits easier.
Those commits frequently get produced when making changes to <code>workspace.josh</code> files.</p>
<p>The command should be put into <code>PATH</code> and can be used as a drop-in replacement for <code>git push</code>.
It enables the server to <em>return</em> commits back to the client after a push. This is done by parsing
the messages sent back by the server for announcements of rewritten commits and then fetching
those to update the local references.
In case of a normal git server that does not rewrite anything, <code>git sync</code> will do exactly the
same as <code>git push</code>, also accepting the same arguments.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
