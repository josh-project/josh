<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Just One Single History</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="usecases.html"><strong aria-hidden="true">2.</strong> Use cases</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">3.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Guide</li><li class="chapter-item expanded "><a href="guide/gettingstarted.html"><strong aria-hidden="true">4.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="guide/workspaces.html"><strong aria-hidden="true">5.</strong> Working with workspaces</a></li><li class="chapter-item expanded "><a href="guide/importing.html"><strong aria-hidden="true">6.</strong> Importing projects</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Integrating with CI</div></li><li class="chapter-item expanded affix "><li class="part-title">Reference</li><li class="chapter-item expanded "><a href="reference/filters.html"><strong aria-hidden="true">8.</strong> Filter syntax</a></li><li class="chapter-item expanded "><a href="reference/proxy.html"><strong aria-hidden="true">9.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="reference/workspace.html"><strong aria-hidden="true">10.</strong> Workspaces</a></li><li class="chapter-item expanded "><a href="reference/container.html"><strong aria-hidden="true">11.</strong> Container configuration</a></li><li class="chapter-item expanded "><a href="reference/cli.html"><strong aria-hidden="true">12.</strong> Command line tools</a></li><li class="chapter-item expanded "><a href="reference/graphql.html"><strong aria-hidden="true">13.</strong> Graphql API</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Handlebar generator</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> The josh UI</div></li><li class="chapter-item expanded affix "><li class="part-title">Contributing</li><li class="chapter-item expanded "><a href="contributing/testing.html"><strong aria-hidden="true">16.</strong> Testing</a></li><li class="chapter-item expanded "><a href="contributing/dev-tools.html"><strong aria-hidden="true">17.</strong> Development tools</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Tracing</div></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Just One Single History</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="https://raw.githubusercontent.com/josh-project/josh/master/splash.png" alt="Just One Single History" /></p>
<p>Josh combines the advantages of monorepos with those of multirepos by leveraging a blazingly-fast,
incremental, and reversible implementation of git history filtering.</p>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<p>Traditionally, history filtering has been viewed as an expensive operation that should only be
performed to fix issues with a repository, such as purging big binary files or removing
accidentally-committed secrets, or as part of a migration to a different repository structure, like
switching from multirepo to monorepo (or vice versa).</p>
<p>The implementation shipped with git (<code>git-filter branch</code>) is only usable as a once-in-a-lifetime
last resort for anything but tiny repositories.</p>
<p>Faster versions of history filtering have been implemented, such as
<a href="https://github.com/newren/git-filter-repo">git-filter-repo</a> or the
<a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG repo cleaner</a>. Those, while much faster, are
designed for doing occasional, destructive maintenance tasks, usually with the idea already in mind
that once the filtering is complete the old history should be discarded.</p>
<p>The idea behind <code>josh</code> started with two questions:</p>
<ol>
<li>What if history filtering could be so fast that it can be part of a normal, everyday workflow,
running on every single push and fetch without the user even noticing?</li>
<li>What if history filtering was a non-destructive, reversible operation?</li>
</ol>
<p>Under those two premises a filter operation stops being a maintenance task. It seamlessly relates
histories between repos, which can be used by developers and CI systems interchangeably in whatever
way is most suitable to the task at hand.</p>
<p>How is this possible?</p>
<p>Filtering history is a highly predictable task: The set of filters that tend to be used for any
given repository is limited, such that the input to the filter (a git branch) only gets modified in
an incremental way. Thus, by keeping a persistent cache between filter runs, the work needed to
re-run a filter on a new commit (and its history) becomes proportional to the number of changes
since the last run; The work to filter no longer depends on the total length of the history.
Additionally, most filters also do not depend on the size of the trees.</p>
<p>What has long been known to be true for performing merges also applies to history filtering: The
more often it is done the less work it takes each time.</p>
<p>To guarantee filters are reversible we have to restrict the kind of filter that can be used; It is
not possible to write arbitrary filters using a scripting language like is allowed in other tools.
To still be able to cover a wide range of use cases we have introduced a domain-specific language to
express more complex filters as a combination of simpler ones. Apart from guaranteeing
reversibility, the use of a DSL also enables pre-optimization of filter expressions to minimize both
the amount of work to be done to execute the filter as well as the on-disk size of the persistent
cache.</p>
<blockquote>
<p><em><em>From Linus Torvalds 2007 talk at Google about git:</em></em></p>
<p><strong>Audience:</strong></p>
<p>Can you have just a part of files pulled out of a repository, not the entire repository?</p>
<p><strong>Linus:</strong></p>
<p>You can export things as tarballs, you can export things as individual files, you can rewrite the
whole history to say &quot;I want a new version of that repository that only contains that part&quot;, you
can do that, it is a fairly expensive operation it's something you would do for example when you
import an old repository into a one huge git repository and then you can split it later on to be
multiple smaller ones, you can do it, what I am trying to say is that you should generally try to
avoid it. It's not that git cannot handle huge projects, git would not perform as well as it would
otherwise. And you will have issues that you wish you didn't not have.</p>
<p>So I am skipping this issue and going back to the performance issue. One of the things I want to
say about performance is that a lot of people seem to think that performance is about doing the
same thing, just doing it faster, and that is not true.</p>
<p>That is not what performance is all about. If you can do something really fast, really well, people
will start using it differently.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h1>
<h3 id="partial-cloning"><a class="header" href="#partial-cloning">Partial cloning</a></h3>
<p>Reduce scope and size of clones by treating subdirectories of the monorepo
as individual repositories.</p>
<pre><code>$ git clone http://josh/monorepo.git:/path/to/library.git
</code></pre>
<p>The partial repo will act as a normal git repository but only contain the files
found in the subdirectory and only commits affecting those files.
The partial repo supports both fetch as well as push operation.</p>
<p>This helps not just to improve performance on the client due to having fewer files in
the tree,
it also enables collaboration on parts of the monorepo with other parties
utilizing git's normal distributed development features.
For example, this makes it easy to mirror just selected parts of your
repo to public github repositories or specific customers.</p>
<h3 id="project-composition--workspaces"><a class="header" href="#project-composition--workspaces">Project composition / Workspaces</a></h3>
<p>Simplify code sharing and dependency management. Beyond just subdirectories,
Josh supports filtering, re-mapping and composition of arbitrary virtual repositories
from the content found in the monorepo.</p>
<p>The mapping itself is also stored in the repository and therefore versioned alongside
the code.</p>
<p>Multiple projects, depending on a shared set of libraries, can thus live together in a single repository.
This approach is commonly referred to as “monorepo”, and was popularized by
<a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">Google</a>, Facebook or Twitter to name a
few.</p>
<p>In this example, two projects (<code>project1</code> and <code>project2</code>) coexist in the <code>central</code> monorepo.</p>
<table>
    <thead>
        <tr>
            <th>Central monorepo</th>
            <th>Project workspaces</th>
            <th>workspace.josh file</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=2><img src="./img/central.svg?sanitize=true" alt="Folders and files in central.git" /></td>
            <td><img src="./img/project1.svg?sanitize=true" alt="Folders and files in project1.git" /></td>
            <td>
<pre>
dependencies = :/modules:[
    ::tools/
    ::library1/
]
</pre>
        </tr>
        <tr>
            <td><img src="./img/project2.svg?sanitize=true" alt="Folders and files in project2.git" /></td>
            <td>
<pre>libs/library1 = :/modules/library1</pre></td>
        </tr>
    </tbody>
</table>
<p>Workspaces act as normal git repos:</p>
<pre><code>$ git clone http://josh/central.git:workspace=workspaces/project1.git
</code></pre>
<p>Each of the subprojects defines a <code>workspace.josh</code> file, defining the mapping between the original central.git repository and the hierarchy in use inside of the project.</p>
<p>In this setup, project1 and project2 can seamlessly depend on the latest version of library1, while only checking out the part of the central monorepo that's needed for their purpose.
What's more, any changes to a shared module will be synced in both directions.</p>
<p>If a developer of the library1 pushed a new update, both projects will get the new version, and the developer will be able to check if they broke any test.
If a developer of project1 needs to update the library, the changes will be automatically shared back into central, and project2.</p>
<h3 id="simplified-cicd"><a class="header" href="#simplified-cicd">Simplified CI/CD</a></h3>
<p>With everything stored in one repo, CI/CD systems only need to look into one source for each particular
deliverable.
However in traditional monorepo environments dependency management is handled by the build system.
Build systems are usually tailored to specific languages and need their input already checked
out on the filesystem.
So the question:</p>
<blockquote>
<p>&quot;What deliverables are affected by a given commit and need to be rebuild?&quot;</p>
</blockquote>
<p>cannot be answered without cloning the entire repository and understanding how the languages
used handle dependencies.</p>
<p>In particular when using C family languages, hidden dependencies on header files are easy to miss.
For this reason limiting the visibility of files to the compiler by sandboxing is pretty much a requirement
for reproducible builds.</p>
<p>With Josh, each deliverable gets its own virtual git repository with dependencies declared in the <code>workspace.josh</code>
file. This means answering the above question becomes as simple as comparing commit ids.
Furthermore due to the tree filtering each build is guaranteed to be perfectly sandboxed
and only sees those parts of the monorepo that have actually been mapped.</p>
<p>This also means the deliverables to be re-built can be determined without cloning any repos like
typically necessary with normal build tools.</p>
<h3 id="graphql-api"><a class="header" href="#graphql-api">GraphQL API</a></h3>
<p>It is often desireable to access content stored in git without requiring a clone of the repository.
This is useful for CI/CD systems or web frontends such as dashboards.</p>
<p>Josh exposes a GraphQL API for that purpose. For example, it can be used to find all workspaces currently
present in the tree:</p>
<pre><code>query {
  rev(at:&quot;refs/heads/master&quot;, filter:&quot;::**/workspace.josh&quot;) {
    files { path }
  }
}
</code></pre>
<h3 id="caching-proxy"><a class="header" href="#caching-proxy">Caching proxy</a></h3>
<p>Even without using the more advanced features like partial cloning or workspaces,
<code>josh-proxy</code> can act as a cache to reduce traffic between locations or keep your CI from
performing many requests to the main git host.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently Asked Questions</a></h1>
<h2 id="how-is-josh-different-from-git-sparse-checkout"><a class="header" href="#how-is-josh-different-from-git-sparse-checkout">How is Josh different from git sparse-checkout?</a></h2>
<p>Josh operates on the git object graph and is unrelated to checking out files and the working tree on the filesystem, which is the only thing sparse-checkout is concerned with. A sparse checkout does not influence the contents of the object database and also not what gets downloaded over the network.
Both can certainly be used together if needed.</p>
<h2 id="how-is-josh-different-from-partial-clone"><a class="header" href="#how-is-josh-different-from-partial-clone">How is Josh different from partial clone?</a></h2>
<p>A partial clone will cause git to download only parts of an object database according to some predicate. It is still the same object database with the history having the same commits and sha1s. It still allows loading skipped parts of the object database at a later point.
Josh creates an alternate history that has no reference to the skipped parts. It is as such very similar to git filter-branch just faster, with added features and a different user interface.</p>
<h2 id="how-is-it-different-from-submodules"><a class="header" href="#how-is-it-different-from-submodules">How is it different from submodules?</a></h2>
<p>Where git submodules are multiple, independent repos, referencing each other with SHAs, Josh supports the monorepo approach.
All of the code is in one single repo which can easily be kept in sync, and Josh provides any sub folder (or in the case of workspaces, more complicated recombination of folders) as their own git repository.
These repos are transparently synchronised both ways with the main monorepo.
Josh can thus do more than submodules can, and is easier and faster to use.</p>
<h2 id="how-is-it-different-from-git-subtree"><a class="header" href="#how-is-it-different-from-git-subtree">How is it different from <code>git subtree</code>?</a></h2>
<p>The basic idea behind Josh is quite similar to <code>git subtree</code>. However <code>git subtree</code>, just like <code>git filter-branch</code>, is way too slow for everyday use, even on medium sized repos.
<code>git subtree</code> can only achieve acceptable performance when squashing commits and therefore losing history. One core part of Josh is essentially a much faster implementation
of <code>git subtree split</code> which has been specifically optimized for being run frequently inside the same repository.</p>
<h2 id="how-is-josh-different-from-git-filter-repo"><a class="header" href="#how-is-josh-different-from-git-filter-repo">How is Josh different from <code>git filter-repo</code>?</a></h2>
<p>Both  <code>josh-filter</code> as well as <code>git filter-repo</code> enable very fast rewriting of Git history and thus can in simple cases be used
for the same purpose.</p>
<p>Which one is right in more advanced use cases depends on your goals: <code>git filter-repo</code> offers more flexibility and options
on what kind of filtering it supports, like rewriting commit messages or even plugging arbitrary scripts into the filtering.</p>
<p>Josh uses a DSL instead of arbitrary scripts for complex filters and is much more restrictive in the kind of filtering
possible, but in exchange for those limitations offers incremental filtering as well as bidirectional operation, meaning converting changes between both the original and the filtered repos.</p>
<h2 id="how-is-josh-different-from-all-of-the-above-alternatives"><a class="header" href="#how-is-josh-different-from-all-of-the-above-alternatives">How is Josh different from all of the above alternatives?</a></h2>
<p>Josh includes <code>josh-proxy</code> which offers repo filtering as a service, mainly intended to support monorepo workflows.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>This book will guide you into setting up the josh
proxy to serve your own git repository.</p>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>All the commands are included from the file <code>gettingstarted.t</code>
which can be run with <a href="https://bitheap.org/cram/">cram</a>.</p>
</blockquote>
<h2 id="setting-up-the-proxy"><a class="header" href="#setting-up-the-proxy">Setting up the proxy</a></h2>
<p>Josh is distributed via <a href="https://hub.docker.com/r/joshproject/josh-proxy">Docker Hub</a>,
and is installed and started with the following command:</p>
<pre><code class="language-shell">  $ docker run \
  &gt;   --name josh-proxy \
  &gt;   --detach \
  &gt;   --publish 8000:8000 \
  &gt;   --env JOSH_REMOTE=https://github.com \
  &gt;   --volume josh-vol:/data/git \
  &gt;   joshproject/josh-proxy:latest &gt;/dev/null
</code></pre>
<p>This starts Josh as a proxy to <code>github.com</code>, in a Docker container, 
creating a volume <code>josh-vol</code> and mounting it to the image for use by Josh.</p>
<h2 id="cloning-a-repository"><a class="header" href="#cloning-a-repository">Cloning a repository</a></h2>
<p>Once Josh is running, we can clone a repository through it.
For example, let's clone Josh:</p>
<pre><code class="language-shell">  $ git clone http://localhost:8000/josh-project/josh.git
  Cloning into 'josh'...
  $ cd josh
</code></pre>
<p>As we can see, this repository is simply the normal Josh one:</p>
<pre><code class="language-shell">  $ ls
  Cargo.lock
  Cargo.toml
  Dockerfile
  Dockerfile.tests
  LICENSE
  Makefile
  README.md
  docs
  josh-proxy
  run-josh.sh
  run-tests.sh
  rustfmt.toml
  scripts
  src
  static
  tests
  $ git log -2
  commit fc6af1e10c865f790bff7135d02b1fa82ddebe29
  Author: Christian Schilling &lt;christian.schilling@esrlabs.com&gt;
  Date:   Fri Mar 19 11:15:57 2021 +0100
  
      Update release.yml
  
  commit 975581064fa21b3a3d6871a4e888fd6dc1129a13
  Author: Christian Schilling &lt;christian.schilling@esrlabs.com&gt;
  Date:   Fri Mar 19 11:11:45 2021 +0100
  
      Update release.yml
</code></pre>
<h2 id="cloning-a-part-of-the-repo"><a class="header" href="#cloning-a-part-of-the-repo">Cloning a part of the repo</a></h2>
<p>Josh becomes interesting when we want to clone a part of the repo.
Let's check out the Josh repository again, but this time let's filter
only the documentation out:</p>
<pre><code class="language-shell">  $ cd ..
  $ git clone http://localhost:8000/josh-project/josh.git:/docs.git
  Cloning into 'docs'...
  $ cd docs
</code></pre>
<p>Note the addition of <code>:/docs</code> at the end of the url.
This is called a filter, and it instructs josh to only check out the
given folder.</p>
<p>Looking inside the repository, we now see that the history is quite
different. Indeed, it contains only the commits pertaining to the 
subfolder that we checked out.</p>
<pre><code class="language-shell">  $ ls
  book.toml
  src
  $ git log -2
  commit dd26c506f6d6a218903b9f42a4869184fbbeb940
  Author: Christian Schilling &lt;christian.schilling@esrlabs.com&gt;
  Date:   Mon Mar 8 09:22:21 2021 +0100
  
      Update docs to use docker for default setup
  
  commit ee6abba0fed9b99c9426f5224ff93cfee2813edc
  Author: Louis-Marie Givel &lt;louis-marie.givel@esrlabs.com&gt;
  Date:   Fri Feb 26 11:41:37 2021 +0100
  
      Update proxy.md
</code></pre>
<p>This repository is a real repository in which we can pull, commit, push,
as with a regular one. Josh will take care of synchronizing it with
the main one in a transparent fashion.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-workspaces"><a class="header" href="#working-with-workspaces">Working with workspaces</a></h1>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>All the commands are included from the file <code>workspaces.t</code>
which can be run with <a href="https://bitheap.org/cram/">cram</a>.</p>
</blockquote>
<p>Josh really starts to shine when using workspaces.</p>
<p>Simply put, they are a list of files and folders, remapped from the central repository
to a new repository.
For example, a shared library could be used by various workspaces, each mapping it to
their appropriate subdirectory.</p>
<p>In this chapter, we're going to set up a new git repository with a couple of libraries,
and then use it to demonstrate the use of workspaces.</p>
<h2 id="test-set-up"><a class="header" href="#test-set-up">Test set-up</a></h2>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>The following section describes how to set-up a local git server with made-up content
for the sake of this tutorial.
You're free to follow it, or to use your own existing repository, in which case you
can skip to the next section</p>
</blockquote>
<p>To host the repository for this test, we need a git server.
We're going to run git as a <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">cgi</a>
program using its provided http backend, served with the test server included in
the <a href="https://crates.io/crates/hyper_cgi">hyper_cgi</a> crate.</p>
<h3 id="serving-the-git-repo"><a class="header" href="#serving-the-git-repo">Serving the git repo</a></h3>
<p>First, we create a <em>bare</em> repository, which will be served by hyper_cgi. We enable
the option <code>http.receivepack</code> to allow the use of <code>git push</code> from the clients.</p>
<pre><code class="language-shell">  $ git init --bare ./remote/real_repo.git/
  Initialized empty Git repository in */real_repo.git/ (glob)
  $ git config -f ./remote/real_repo.git/config http.receivepack true
</code></pre>
<p>Then we start the server which will allow clients to access the repository through
http.</p>
<pre><code class="language-shell">  $ GIT_DIR=./remote/ GIT_PROJECT_ROOT=${TESTTMP}/remote/ GIT_HTTP_EXPORT_ALL=1 hyper-cgi-test-server\
  &gt;  --port=8001\
  &gt;  --dir=./remote/\
  &gt;  --cmd=git\
  &gt;  --args=http-backend\
  &gt;  &gt; ./hyper-cgi-test-server.out 2&gt;&amp;1 &amp;
  $ echo $! &gt; ./server_pid
</code></pre>
<p>Our server is ready, serving all the repos in the <code>remote</code> folder on port <code>8001</code>.</p>
<pre><code class="language-shell">  $ git clone http://localhost:8001/real_repo.git
  Cloning into 'real_repo'...
  warning: You appear to have cloned an empty repository.
</code></pre>
<h3 id="adding-some-content"><a class="header" href="#adding-some-content">Adding some content</a></h3>
<p>Of course, the repository is for now empty, and we need to populate it.
The <a href="guide/populate.sh">populate.sh</a> script creates a couple of libraries, as well as two applications that use
them.</p>
<pre><code class="language-shell">  $ cd real_repo
  $ sh ${TESTDIR}/populate.sh &gt; ../populate.out

  $ git push origin HEAD
  To http://localhost:8001/real_repo.git
   * [new branch]      HEAD -&gt; master

  $ tree
  .
  |-- application1
  |   `-- app.c
  |-- application2
  |   `-- guide.c
  |-- doc
  |   |-- guide.md
  |   |-- library1.md
  |   `-- library2.md
  |-- library1
  |   `-- lib1.h
  `-- library2
      `-- lib2.h
  
  5 directories, 7 files
  $ git log --oneline --graph
  * f65e94b Add documentation
  * f240612 Add application2
  * 0a7f473 Add library2
  * 1079ef1 Add application1
  * 6476861 Add library1
</code></pre>
<h2 id="creating-our-first-workspace"><a class="header" href="#creating-our-first-workspace">Creating our first workspace</a></h2>
<p>Now that we have a git repo populated with content, let's serve it through josh:</p>
<pre><code class="language-shell">$ docker run -d --network=&quot;host&quot; -e JOSH_REMOTE=http://127.0.0.1:8001 -v josh-vol:$(pwd)/git_data joshproject/josh-proxy:latest &gt; josh.out
</code></pre>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>For the sake of this example, we run docker with --network=&quot;host&quot; instead of publishing the port.
This is so that docker can access localhost, where our ad-hoc git repository is served.</p>
</blockquote>
<p>To facilitate developement on applications 1 and 2, we want to create workspaces for them.
Creating a new workspace looks very similar to checking out a subfolder through josh, as explained
in &quot;Getting Started&quot;.</p>
<p>Instead of just the name of the subfolder, though, we also use the <code>:workspace=</code> filter:</p>
<pre><code class="language-shell">  $ git clone http://127.0.0.1:8000/real_repo.git:workspace=application1.git application1
  Cloning into 'application1'...
  $ cd application1
  $ tree
  .
  `-- app.c
  
  0 directories, 1 file
  $ git log -2
  commit 50cd6112e173df4cac1aca9cb88b5c2a180bc526
  Author: Josh &lt;josh@example.com&gt;
  Date:   Thu Apr 7 22:13:13 2005 +0000
  
      Add application1
</code></pre>
<p>Looking into the newly cloned workspace, we see our expected files and the history containing the
only relevant commit.</p>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p>Josh allows us to create a workspace out of any directory, even one that doesn't exist yet.</p>
</blockquote>
<h3 id="adding-workspacejosh"><a class="header" href="#adding-workspacejosh">Adding workspace.josh</a></h3>
<p>The workspace.josh file describes how folders from the central repository (real_repo.git)
should be mapped to the workspace repository.</p>
<p>Since we depend on library1, let's add it to the workspace file.</p>
<pre><code class="language-shell">  $ echo &quot;modules/lib1 = :/library1&quot; &gt;&gt; workspace.josh

  $ git add workspace.josh

  $ git commit -m &quot;Map library1 to the application1 workspace&quot;
  [master 06361ee] Map library1 to the application1 workspace
   1 file changed, 1 insertion(+)
   create mode 100644 workspace.josh
</code></pre>
<p>We decided to map library1 to modules/lib1 in the workspace.
We can now sync up with the server:</p>
<pre><code class="language-shell">  $ git sync origin HEAD
    HEAD -&gt; refs/heads/master
  From http://127.0.0.1:8000/real_repo.git:workspace=application1
   * branch            753d62ca1af960a3d071bb3b40722471228abbf6 -&gt; FETCH_HEAD
  HEAD is now at 753d62c Map library1 to the application1 workspace
  Pushing to http://127.0.0.1:8000/real_repo.git:workspace=application1.git
  POST git-receive-pack (477 bytes)
  remote: josh-proxy        
  remote: response from upstream:        
  remote: To http://localhost:8001/real_repo.git        
  remote:    f65e94b..37184cc  JOSH_PUSH -&gt; master        
  remote: REWRITE(06361eedf6d6f6d7ada6000481a47363b0f0c3de -&gt; 753d62ca1af960a3d071bb3b40722471228abbf6)        
  remote: 
  remote: 
  updating local tracking ref 'refs/remotes/origin/master'
  
</code></pre>
<p>let's observe the result:</p>
<pre><code class="language-shell">  $ tree
  .
  |-- app.c
  |-- modules
  |   `-- lib1
  |       `-- lib1.h
  `-- workspace.josh
  
  2 directories, 3 files
  $ git log --graph --oneline
  *   753d62c Map library1 to the application1 workspace
  |\  
  | * 366adba Add library1
  * 50cd611 Add application1
</code></pre>
<p>After pushing and fetching the result, we see that it has been successfully mapped by josh.</p>
<p>One suprising thing is the history: our &quot;mapping&quot; commit became a merge commit!
This is because josh needs to merge the history of the module we want to map into the
repository of the workspace.
After this is done, all commits will be present in both of the histories.</p>
<blockquote>
<p><em><strong>NOTE</strong></em></p>
<p><code>git sync</code> is a utility provided with josh which will push contents, and, if josh tells
it to, fetch the transformed result. Otherwise, it works like git push.</p>
</blockquote>
<p>By the way, what does the history look like on the real_repo ?</p>
<pre><code class="language-shell">  $ cd ../real_repo
  $ git pull origin master
  From http://localhost:8001/real_repo
   * branch            master     -&gt; FETCH_HEAD
     f65e94b..37184cc  master     -&gt; origin/master
  Updating f65e94b..37184cc
  Fast-forward
   application1/workspace.josh | 1 +
   1 file changed, 1 insertion(+)
   create mode 100644 application1/workspace.josh
  Current branch master is up to date.

  $ tree
  .
  |-- application1
  |   |-- app.c
  |   `-- workspace.josh
  |-- application2
  |   `-- guide.c
  |-- doc
  |   |-- guide.md
  |   |-- library1.md
  |   `-- library2.md
  |-- library1
  |   `-- lib1.h
  `-- library2
      `-- lib2.h
  
  5 directories, 8 files
  $ git log --graph --oneline
  * 37184cc Map library1 to the application1 workspace
  * f65e94b Add documentation
  * f240612 Add application2
  * 0a7f473 Add library2
  * 1079ef1 Add application1
  * 6476861 Add library1

</code></pre>
<p>We can see the newly added commit for workspace.josh in application1, and as expected,
no merge here.</p>
<h3 id="interacting-with-workspaces"><a class="header" href="#interacting-with-workspaces">Interacting with workspaces</a></h3>
<p>Let's now create a second workspace, this time for application2.
It depends on library1 and library2.</p>
<pre><code class="language-shell">  $ git clone http://127.0.0.1:8000/real_repo.git:workspace=application2.git application2
  Cloning into 'application2'...
  $ cd application2
  $ echo &quot;libs/lib1 = :/library1&quot; &gt;&gt; workspace.josh
  $ echo &quot;libs/lib2 = :/library2&quot; &gt;&gt; workspace.josh
  $ git add workspace.josh &amp;&amp; git commit -m &quot;Create workspace for application2&quot;
  [master 566a489] Create workspace for application2
   1 file changed, 2 insertions(+)
   create mode 100644 workspace.josh
</code></pre>
<p>Syncing as before:</p>
<pre><code class="language-shell">  $ git sync origin HEAD
    HEAD -&gt; refs/heads/master
  From http://127.0.0.1:8000/real_repo.git:workspace=application2
   * branch            5115fd2a5374cbc799da61a228f7fece3039250b -&gt; FETCH_HEAD
  HEAD is now at 5115fd2 Create workspace for application2
  Pushing to http://127.0.0.1:8000/real_repo.git:workspace=application2.git
  POST git-receive-pack (478 bytes)
  remote: josh-proxy        
  remote: response from upstream:        
  remote: To http://localhost:8001/real_repo.git        
  remote:    37184cc..feb3a5b  JOSH_PUSH -&gt; master        
  remote: REWRITE(566a4899f0697d0bde1ba064ed81f0654a316332 -&gt; 5115fd2a5374cbc799da61a228f7fece3039250b)        
  remote: 
  remote: 
  updating local tracking ref 'refs/remotes/origin/master'
  
</code></pre>
<p>And our local folder now contains all the files requested:</p>
<pre><code class="language-shell">  $ tree
  .
  |-- guide.c
  |-- libs
  |   |-- lib1
  |   |   `-- lib1.h
  |   `-- lib2
  |       `-- lib2.h
  `-- workspace.josh
  
  3 directories, 4 files
</code></pre>
<p>And the history includes the history of both of the libraries:</p>
<pre><code class="language-shell">  $ git log --oneline --graph
  *   5115fd2 Create workspace for application2
  |\  
  | * ffaf58d Add library2
  | * f4e4e40 Add library1
  * ee8a5d7 Add application2
</code></pre>
<p>Note that since we created the workspace and added the dependencies in one single commit,
the history just contains this one single merge commit.</p>
<h4 id="pushing-a-change-from-a-workspace"><a class="header" href="#pushing-a-change-from-a-workspace">Pushing a change from a workspace</a></h4>
<p>While testing application2, we noticed a typo in the <code>library1</code> dependency.
Let's go ahead a fix it!</p>
<pre><code class="language-shell">  $ sed -i 's/41/42/' libs/lib1/lib1.h
  $ git commit -a -m &quot;fix lib1 typo&quot;
  [master 82238bf] fix lib1 typo
   1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre>
<p>We can push this change like any normal git change:</p>
<pre><code class="language-shell">  $ git push origin master
  remote: josh-proxy        
  remote: response from upstream:        
  remote: To http://localhost:8001/real_repo.git        
  remote:    feb3a5b..31e8fab  JOSH_PUSH -&gt; master        
  remote: 
  remote: 
  To http://127.0.0.1:8000/real_repo.git:workspace=application2.git
     5115fd2..82238bf  master -&gt; master
</code></pre>
<p>Since the change was merged in the central repository, 
a developer can now pull from the application1 workspace.</p>
<pre><code class="language-shell">  $ cd ../application1
  $ git pull
  From http://127.0.0.1:8000/real_repo.git:workspace=application1
   + 06361ee...c64b765 master     -&gt; origin/master  (forced update)
  Updating 753d62c..c64b765
  Fast-forward
   modules/lib1/lib1.h | 2 +-
   1 file changed, 1 insertion(+), 1 deletion(-)
  Current branch master is up to date.
</code></pre>
<p>The change has been propagated!</p>
<pre><code class="language-shell">  $ git log --oneline --graph
  * c64b765 fix lib1 typo
  *   753d62c Map library1 to the application1 workspace
  |\  
  | * 366adba Add library1
  * 50cd611 Add application1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="importing-projects"><a class="header" href="#importing-projects">Importing projects</a></h1>
<p>When moving to a monorepo setup, especially in existing organisations,
it is common that the need to consolidate existing project
repositories arises.</p>
<p>The simplest possible case is one where the previous history of a
project does not need to be retained. In this case, the projects files
can simply be copied into the monoreop at the appropriate location and
committed.</p>
<p>If history should be retained, josh can be used for importing a
project as an alternative to built-in git commands like <a href="https://manpages.debian.org/testing/git-man/git-subtree.1.en.html"><code>git subtree</code></a>.</p>
<p>Josh's <a href="guide/../reference/filters.html">filter capability</a> lets you perform
transformations on the history of a git repository to arbitrarily
(re-)compose paths inside of a repository.</p>
<p>A key aspect of this functionality is that all transformations are
<em>reversible</em>. This means that if you apply a transformation moving
files from the root of a repository to, say, <code>tools/project-b</code>,
followed by an <em>inverse</em> transformation moving files from
<code>tools/project-b</code> back to the root, you receive the same commit hashes
you put in.</p>
<p>We can use this feature to import a project into our monorepo while
allowing external users to keep pulling on top of the same git history
they already have, just with a new git remote.</p>
<p>There are multiple ways of doing this, with the most common ones
outlined below. You can look at <a href="https://github.com/josh-project/josh/issues/596"><code>josh#596</code></a> for a
discussion of several other methods.</p>
<h3 id="import-with-josh-filter"><a class="header" href="#import-with-josh-filter">Import with <code>josh-filter</code></a></h3>
<p>Currently, the easiest way to do this is by using the <code>josh-filter</code>
binary which is a command-line frontend to josh's filter capabilities.</p>
<p>Inside of our target repository, it would work like this:</p>
<ol>
<li>
<p>Fetch the repository we want to import (say, &quot;Project B&quot;, from
<code>$REPO_URL</code>).</p>
<pre><code class="language-sh">$ git fetch $REPO_URL master
</code></pre>
<p>This will set the <code>FETCH_HEAD</code> reference to the fetched repository.</p>
</li>
<li>
<p>Rewrite the history of that repository through josh to make it look
as if the project had always been developed at our target path
(say, <code>tools/project-b</code>).</p>
<pre><code class="language-sh">$ josh-filter ':prefix=tools/project-b' FETCH_HEAD
</code></pre>
<p>This will set the <code>FILTERED_HEAD</code> reference to the rewritten
history.</p>
</li>
<li>
<p>Merge the rewritten history into our target repository.</p>
<pre><code class="language-sh">$ git merge --allow-unrelated FILTERED_HEAD
</code></pre>
<p>After this merge commit, the previously external project now lives
at <code>tools/project-b</code> as expected.</p>
</li>
<li>
<p>Any external users can now use the <code>:/tools/project-b</code> josh filter
to retrieve changes made in the new project location - without the
git hashes of their existing commits changing (that is to say,
without conflicting).</p>
</li>
</ol>
<h3 id="import-by-pushing-to-josh"><a class="header" href="#import-by-pushing-to-josh">Import by pushing to josh</a></h3>
<p>If your monorepo is already running a <code>josh-proxy</code> in front of it, you
can also import a project by pushing a project merge to josh.</p>
<p>This has the benefit of not needing to clone the entire monorepo
locally to do a merge, but the drawback of using a different, slightly
slower filter mechanism when exporting the tree back out. For projects
with very large history, consider using the <code>josh-filter</code> mechanism
outlined above.</p>
<p>Pushing a project merge to josh works like this:</p>
<ol>
<li>
<p>Assume we have a local checkout of &quot;Project B&quot;, and we want to
merge this into our monorepo. There is a <code>josh-proxy</code> running at
<code>https://git.company.name/monorepo.git</code>. We want to merge this
project into <code>/tools/project-b</code> in the monorepo.</p>
</li>
<li>
<p>In the checkout of &quot;Project B&quot;, add the josh remote:</p>
<pre><code class="language-sh">git remote add josh https://git.company.name/monorepo.git:/tools/project-b.git
</code></pre>
<p>Note the use of the <code>/tools/project-b.git</code> josh filter, which
points to a path that should not yet exist in the monorepo.</p>
</li>
<li>
<p>Push the repository to josh with the <code>-o merge</code> option, creating a
merge commit introducing the project history at that location,
while retaining its history:</p>
<pre><code class="language-sh">git push josh $ref -o merge
</code></pre>
</li>
</ol>
<h3 id="note-for-gerrit-users"><a class="header" href="#note-for-gerrit-users">Note for Gerrit users</a></h3>
<p>With either method, when merging a set of new commits into a Gerrit
repository and going through the standard code-review process, Gerrit
might complain about missing Change-IDs in the imported commits.</p>
<p>To work around this, the commits need to first be made &quot;known&quot; to
Gerrit. This can be achieved by pushing the new parent of the merge
commit to a separate branch in Gerrit directly (without going through
the review mechanism). After this Gerrit will accept merge commits
referencing that parent, as long as the merge commit itself has a
Change-ID.</p>
<p>Some monorepo setups on Gerrit use a special unrestricted branch like
<code>merge-staging</code> for this, to which users with permission to import
projects can force-push unrelated histories.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="history-filtering"><a class="header" href="#history-filtering">History filtering</a></h1>
<p>Josh transforms commits by applying filters to them. As any
commit in git represents not just a single state of the file system but also its entire
history, applying a filter to a commit produces an entirely new history.
The result of a filter is a normal git commit and therefore can be filtered again,
making filters chainable.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Filters always begin with a colon and can be chained:</p>
<pre><code>:filter1:filter2
</code></pre>
<p>When used as part of an URL filters cannot contain white space or newlines. When read from a file
however white space can be inserted between filters (not after the leading colon).
Additionally newlines can be used instead of <code>,</code> inside of composition filters.</p>
<p>Some filters take arguments, and arguments can optionally be quoted using double quotes,
if special characters used by the filter language need to be used (like <code>:</code> or space):</p>
<pre><code>:filter=argument1,&quot;argument2&quot;
</code></pre>
<h2 id="available-filters"><a class="header" href="#available-filters">Available filters</a></h2>
<h3 id="subdirectory-a"><a class="header" href="#subdirectory-a">Subdirectory <strong><code>:/a</code></strong></a></h3>
<p>Take only the selected subdirectory from the input and make it the root
of the filtered tree.
Note that <code>:/a/b</code> and <code>:/a:/b</code> are equivalent ways to get the same result.</p>
<h3 id="directory-a"><a class="header" href="#directory-a">Directory <strong><code>::a/</code></strong></a></h3>
<p>A shorthand for the commonly occurring filter combination <code>:/a:prefix=a</code>.</p>
<h3 id="file-a"><a class="header" href="#file-a">File <strong><code>::a</code></strong></a></h3>
<p>Produces a tree with only the specified file in it's root.
Note that <code>::a/b</code> is equivalent to <code>::a/::b</code>.</p>
<h3 id="prefix-prefixa"><a class="header" href="#prefix-prefixa">Prefix <strong><code>:prefix=a</code></strong></a></h3>
<p>Take the input tree and place it into subdirectory <code>a</code>.
Note that <code>:prefix=a/b</code> and <code>:prefix=b:prefix=a</code> are equivalent.</p>
<h3 id="composition-filter1filter2filtern"><a class="header" href="#composition-filter1filter2filtern">Composition <strong><code>:[:filter1,:filter2,...,:filterN]</code></strong></a></h3>
<p>Compose a tree by overlaying the outputs of <code>:filter1</code> ... <code>:filterN</code> on top of each other.
It is guaranteed that each file will only appear at most once in the output. The first filter
that consumes a file is the one deciding it's mapped location. Therefore the order in which
filters are composed matters.</p>
<p>Inside of a composition <code>x=:filter</code> can be used as an alternative spelling for
<code>:filter:prefix=x</code>.</p>
<h3 id="exclusion-excludefilter"><a class="header" href="#exclusion-excludefilter">Exclusion <strong><code>:exclude[:filter]</code></strong></a></h3>
<p>Remove all paths present in the <em>output</em> of <code>:filter</code> from the input tree.
It should generally be avoided to use any filters that change paths and instead only
use filters that select paths without altering them.</p>
<h3 id="workspace-workspacea"><a class="header" href="#workspace-workspacea">Workspace <strong><code>:workspace=a</code></strong></a></h3>
<p>Similar to <code>:/a</code> but also looks for a <code>workspace.josh</code> file inside the
specified directory (called the &quot;workspace root&quot;).
The resulting tree will contain the contents of the
workspace root as well as additional files specified in the <code>workspace.josh</code> file.
(see <a href="reference/./workspace.html">Workspaces</a>)</p>
<h3 id="text-replacement-replaceregex_0replacement_0regex_nreplacement_n"><a class="header" href="#text-replacement-replaceregex_0replacement_0regex_nreplacement_n">Text replacement <strong><code>:replace(&quot;regex_0&quot;:&quot;replacement_0&quot;,...,&quot;regex_N&quot;:&quot;replacement_N&quot;)</code></strong></a></h3>
<p>Applies the supplied regular expressions to every file in the input tree.</p>
<h3 id="signature-removal-unsign"><a class="header" href="#signature-removal-unsign">Signature removal <strong><code>:unsign</code></strong></a></h3>
<p>The default behaviour of Josh is to copy, if it exists, the signature of the original commit in
the filtered commit. This makes the signature invalid, but allows a perfect round-trip: josh will be
able to recreate the original commit from the filtered one.</p>
<p>This behaviour might not be desirable, and this filter drops the signatures from the history.</p>
<h2 id="pattern-filters"><a class="header" href="#pattern-filters">Pattern filters</a></h2>
<p>The following filters accept a glob like pattern <code>X</code> that can contain <code>*</code> to
match any number of characters. Note that two or more consecutive wildcards (<code>**</code>) are not
allowed.</p>
<h3 id="match-directories-x"><a class="header" href="#match-directories-x">Match directories <strong><code>::X/</code></strong></a></h3>
<p>All matching subdirectories in the input root</p>
<h3 id="match-files-or-directories-x"><a class="header" href="#match-files-or-directories-x">Match files or directories <strong><code>::X</code></strong></a></h3>
<p>All matching files or directories in the input root</p>
<h3 id="match-nested-directories-x"><a class="header" href="#match-nested-directories-x">Match nested directories <strong><code>::**/X/</code></strong></a></h3>
<p>All subdirectories matching the pattern in arbitrarily deep subdirectories of the input</p>
<h3 id="match-nested-files-x"><a class="header" href="#match-nested-files-x">Match nested files <strong><code>::**/X</code></strong></a></h3>
<p>All files matching the pattern in arbitrarily deep subdirectories of the input</p>
<h2 id="history-filters"><a class="header" href="#history-filters">History filters</a></h2>
<p>These filter do not modify git trees, but instead only operate on the commit graph.</p>
<h3 id="linearise-history-linear"><a class="header" href="#linearise-history-linear">Linearise history <strong>:linear</strong></a></h3>
<p>Produce a filtered history that does not contain any merge commits. This is done by
simply dropping all parents except the first on every commit.</p>
<h3 id="filter-specific-parts-of-the-history-revsha_0filter_0sha_nfilter_n"><a class="header" href="#filter-specific-parts-of-the-history-revsha_0filter_0sha_nfilter_n">Filter specific parts of the history <strong>:rev(&lt;sha_0&gt;:filter_0,...,&lt;sha_N&gt;:filter_N)</strong></a></h3>
<p>Produce a history where the commits specified by <code>&lt;sha_N&gt;</code> are replaced by the result of applying
<code>:filter_N</code> to it.</p>
<p>It will appear like <code>&lt;sha_N&gt;</code> and all its ancestors are also filtered with <code>&lt;filter_N&gt;</code>. If an
ancestor also has a matching entry in the <code>:rev(...)</code> it's filter will <em>replace</em> <code>&lt;filter_N&gt;</code>
for all further ancestors (and so on).</p>
<p>This special value <code>0000000000000000000000000000000000000000</code> can be used as a <code>&lt;sha_n&gt;</code> to filter
commits that don't match any of the other shas.</p>
<h3 id="join-multiple-histories-into-one-joinsha_0filter_0sha_nfilter_n"><a class="header" href="#join-multiple-histories-into-one-joinsha_0filter_0sha_nfilter_n">Join multiple histories into one <strong>:join(&lt;sha_0&gt;:filter_0,...,&lt;sha_N&gt;:filter_N)</strong></a></h3>
<p>Produce the history that would be the result of pushing the passed branches with the
passed filters into the upstream.</p>
<h2 id="filter-order-matters"><a class="header" href="#filter-order-matters">Filter order matters</a></h2>
<p>Filters are applied in the left-to-right order they are given in the filter specification,
and they are <code>not</code> commutative.</p>
<p>For example, this command will filter out just the josh documentation, and store it in a
ref named <code>FILTERED_HEAD</code>:</p>
<pre><code>$ josh-filter :/docs:prefix=josh-docs
</code></pre>
<p>However, <code>this</code> command will produce an empty branch:</p>
<pre><code>$ josh-filter :prefix=josh-docs:/docs
</code></pre>
<p>What's happening in the latter command is that because the prefix filter is applied first, the
entire <code>josh</code> history already lives within the <code>josh-docs</code> directory, as it was just
transformed to exist there. Thus, to still get the docs, the command would need to be:</p>
<pre><code>$ josh-filter :prefix=josh-docs:/josh-docs/docs
</code></pre>
<p>which will contain the josh documentation at the base of the tree. We've lost the prefix, what
gives?? Because the original git tree was already transformed, and then the subdirectory filter
was applied to pull documentation from <code>josh-docs/docs</code>, the prefix is gone - it was filtered out
again by the subdirectory filter. Thus, the order in which filters are provided is crucial, as each
filter further transforms the latest transformation of the tree.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="josh-proxy"><a class="header" href="#josh-proxy">josh-proxy</a></h1>
<p>Josh provides an HTTP proxy server that can be used with any git hosting service which communicates
via HTTP.</p>
<p>It needs the URL of the upstream server and a local directory to store its data.
Optionally, a port to listen on can be specified. For example, running a local <code>josh-proxy</code>
instance for github.com on port 8000:</p>
<pre><code>$ docker run -p 8000:8000 -e JOSH_REMOTE=https://github.com -v josh-vol:/data/git joshproject/josh-proxy:latest
</code></pre>
<blockquote>
<p><strong>Note</strong>: While <code>josh-proxy</code> is intended to be used with a http upstream it can also proxy for
an ssh upstream when <code>ssh</code> is used instead of <code>http</code> in the url.
In that case it will use the ssh private key of the current user (just like
git would) and take the username from the downstream http request.
This mode of operation can be useful for evaluation or local use by individual developers but
should never be used on a normal server deployment.</p>
</blockquote>
<p>For a first example of how to make use of josh, just the josh documentation can be checked out as
its own repository via this command:</p>
<pre><code>$ git clone http://localhost:8000/josh-project/josh.git:/docs.git
</code></pre>
<blockquote>
<p><strong>Note</strong>: This URL needs to contain the <code>.git</code> suffix twice: once after the original path
and once more after the filter spec.</p>
</blockquote>
<p><code>josh-proxy</code> supports read and write access to the repository, so when making changes
to any files in the filtered repository, you can just commit and push them
like you are used to.</p>
<blockquote>
<p><strong>Note</strong>: The proxy is semantically stateless. The data inside the docker volume is only persisted across
runs for performance reasons. This has two important implications for deployment:</p>
<ol>
<li>The data does not need to be backed up unless working with very large repos where rebuilding would
be very expensive. And 2) Multiple instances of josh-proxy can be used interchangeably for availability
or load balancing purposes.</li>
</ol>
</blockquote>
<h2 id="url-syntax-and-breakdown"><a class="header" href="#url-syntax-and-breakdown">URL syntax and breakdown</a></h2>
<p>This is the URL of a <code>josh-proxy</code> instance:</p>
<pre><code>http://localhost:8000
</code></pre>
<p>This is the repository location on the upstream host on which to perform the filter operations:</p>
<pre><code>/josh-project/josh.git
</code></pre>
<p>This is the set of filter operations to perform:</p>
<pre><code>:/docs.git
</code></pre>
<p>Much more information on the available filters and the syntax of all filters is covered in detail in
the <a href="reference/./filters.html">filters</a> section.</p>
<h2 id="repository-naming"><a class="header" href="#repository-naming">Repository naming</a></h2>
<p>By default, a git URL is used to point to the remote repository to download <em>and also</em> to dictate
how the local repository shall be named.  It's important to learn that the last name in the URL is
what the local git client will name the new, local repository. For example:</p>
<pre><code>$ git clone http://localhost:8000/josh-project/josh.git:/docs.git
</code></pre>
<p>will create the new repository at directory <code>docs</code>, as <code>docs.git</code> is the last name in the URL.</p>
<p>By default, this leads to rather odd-looking repositories when the <code>prefix</code> filter is the final
filter of a URL:</p>
<pre><code>$ git clone http://localhost:8000/josh-project/josh.git:/docs:prefix=josh-docs.git
</code></pre>
<p>This will still clone just the josh documentation, but the final directory structure will look like
this:</p>
<pre><code>- prefix=josh-docs
  - josh-docs
    - &lt;docs&gt;
</code></pre>
<p>Having the root repository directory name be the fully-specified filter is most likely not what was
intended. This results from git's reuse and repurposing of the remote URL, as <code>prefix=josh-docs</code>
is the final name in the URL. With no other alternatives, this gets used for the repository name.</p>
<p>To explicitly specify a repository name, provide the desired name after the URL when cloning a new
repository:</p>
<pre><code>$ git clone http://localhost:8000/josh-project/josh.git:/docs:prefix=josh-docs.git my-repo
</code></pre>
<h2 id="serving-a-github-repo"><a class="header" href="#serving-a-github-repo">Serving a github repo</a></h2>
<p>To prompt for authentication, Josh relies on the server requesting it on fetch. When using a server
which doesn't need authentication for fetching, Josh will not automatically prompt for
authentication when pushing, and it will be impossible to provide credentials for pushing.</p>
<p>To solve this, you need to pass the <code>--require-auth</code> option to josh-proxy.
This can be done with <code>JOSH_EXTRA_OPTS</code> when using the docker image like so:</p>
<p><code>docker run -d -p 8000:8000 -e JOSH_EXTRA_OPTS=&quot;--require-auth&quot; -e JOSH_REMOTE=https://github.com/josh-project -v josh-vol:$(pwd)/git_data joshproject/josh-proxy:latest </code></p>
<p>In this example, we serve only the josh-project repositories. Be aware that if you don't add the
organisation or repo URL, your instance will be able to serve all of github. You can (and should)
restrict it to your repository or organisation by making it part of the URL.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-workspaces-1"><a class="header" href="#working-with-workspaces-1">Working with workspaces</a></h1>
<p>For the sake of this example we will assume a <code>josh-proxy</code> instance is running and serving a
repo on <code>http://josh/world.git</code> with some shared code in <code>shared</code>.</p>
<h2 id="create-a-new-workspace"><a class="header" href="#create-a-new-workspace">Create a new workspace</a></h2>
<p>To create a new workspace in the path <code>ws/hello</code> simply clone it as if it already exists:</p>
<pre><code>$ git clone http://josh/world.git:workspace=ws/hello.git
</code></pre>
<p><code>git</code> will report that you appear to have cloned an empty repository if that path does not
yet exist.
If you don't get this message it means that the path already exists in the repo but may
not yet have configured any path mappings.</p>
<p>The next step is to add some path mapping to the <code>workspace.josh</code> file in the root of the
workspace:</p>
<pre><code>$ cd hello
$ echo &quot;mod/a = :/shared/a&quot; &gt; workspace.josh
</code></pre>
<p>And and commit the changes:</p>
<pre><code>$ git add workspace.josh
$ git commit -m &quot;add workspace&quot;
</code></pre>
<p>If the path did not exist previously, the resulting commit will be a root commit that does not share
any history with the <code>world.git</code> repo.
This means a normal <code>git push</code> will be rejected at this point.
To get correct history, the
resulting commit needs to be a based on the history that already exists in <code>world.git</code>.
There is however no way to do this locally, because we don't have the data required for this.
Also, the resulting tree should contain the contents of <code>shared/a</code> mapped to <code>mod/a</code> which
means it needs to be produced on the server side because we don't have the files to put there.</p>
<p>To accomplish that push with the create option:</p>
<pre><code>$ git push -o create origin master
</code></pre>
<blockquote>
<p><strong>Note</strong>: While it is perfectly possible to use Josh without a code review system,
it is strongly recommended to use some form of code review to be able to inspect commits
created by Josh before they get into the immutable history of your main repository.</p>
</blockquote>
<p>As the resulting commit is created on the server side we need to get it from the server:</p>
<pre><code>$ git pull --rebase
</code></pre>
<p>Now you should see <code>mod/a</code> populated with the content of the shared code.</p>
<h2 id="map-a-shared-path-into-a-workspace"><a class="header" href="#map-a-shared-path-into-a-workspace">Map a shared path into a workspace</a></h2>
<p>To add shared path to a location in the workspace that does not exist yet, first add an
entry to the <code>workspace.josh</code> file and commit that.</p>
<p>You can add the mapping at the end of the file using a simple syntax, and rely on josh to rewrite
it for you in a canonical way.</p>
<pre><code>...
new/mapping/location/in/workspace = :/new/mapping/location/in/monorepo
</code></pre>
<p>At this point the path is of course empty, so the commit needs to be pushed to the server.
When the same commit is then fetched back it will have the mapped path populated with the
shared content.</p>
<p>When the commit is pushed, josh will notify you about the rewrite. You can fetch the rewritten 
commit using the advertised SHA.
Alternatively, you can use <a href="reference/./cli.html#git-sync">git sync</a> which will do it for you.</p>
<h2 id="publish-a-non-shared-path-into-a-shared-location"><a class="header" href="#publish-a-non-shared-path-into-a-shared-location">Publish a non-shared path into a shared location</a></h2>
<p>The steps here are exactly the same as for the mapping example above. The only difference being
that the path already exists in the workspace but not in the shared location.</p>
<h2 id="remove-a-mapping"><a class="header" href="#remove-a-mapping">Remove a mapping</a></h2>
<p>To remove a mapping remove the corresponding entry from the <code>workspace.josh</code> file.
The content of the previously shared path will stay in the workspace. That means the main
repo will have two copies of that path from that point on. Effectively creating a fork of that code.</p>
<h2 id="remove-a-mapped-path"><a class="header" href="#remove-a-mapped-path">Remove a mapped path</a></h2>
<p>To remove a mapped path as well as it's contents, remove the entry from the
<code>workspace.josh</code> file and also remove the path inside the workspace using <code>git rm</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="container-configuration"><a class="header" href="#container-configuration">Container configuration</a></h1>
<h2 id="container-options"><a class="header" href="#container-options">Container options</a></h2>
<table>
    <tr>
        <th>
            Variable
        </th>
        <th>
            Meaning
        </th>
    </tr>
    <tr>
        <td>
            <code>JOSH_REMOTE</code>
        </td>
        <td>
            HTTP remote, including protocol.
            Example: <code>https://github.com</code>
        </td>
    </tr>
    <tr>
        <td>
            <code>JOSH_REMOTE_SSH</code>
        </td>
        <td>
            SSH remote, including protocol.
            Example: <code>ssh://git@github.com</code>
        </td>
    </tr>
    <tr>
        <td>
            <code>JOSH_HTTP_PORT</code>
        </td>
        <td>
            HTTP port to listen on.
            Default: 8000
        </td>
    </tr>
    <tr>
        <td>
            <code>JOSH_SSH_PORT</code>
        </td>
        <td>
            SSH port to listen on.
            Default: 8022
        </td>
    </tr>
    <tr>
        <td>
            <code>JOSH_SSH_MAX_STARTUPS</code>
        </td>
        <td>
            Maximum number of concurrent SSH authentication attempts. Default: 16
        </td>
    </tr>
    <tr>
        <td>
            <code>JOSH_SSH_TIMEOUT</code>
        </td>
        <td>
            Timeout, in seconds, for a single request when serving repos over SSH.
            This time should cover fetch from upstream repo, filtering, and serving
            repo to client. Default: 300
        </td>
    </tr>
    <tr>
        <td>
            <code>JOSH_EXTRA_OPTS</code>
        </td>
        <td>
            Extra options passed directly to
            <code>josh-proxy</code> process
        </td>
    </tr>
</table>
<h2 id="container-volumes"><a class="header" href="#container-volumes">Container volumes</a></h2>
<table>
    <tr>
        <th>
            Volume
        </th>
        <th>
            Purpose
        </th>
    </tr>
    <tr>
        <td>
            <code>/data/git</code>
        </td>
        <td>
            Git cache volume. If this volume is not
            mounted, the cache will be lost every time
            the container is shut down.
        </td>
    </tr>
    <tr>
        <td>
            <code>/data/keys</code>
        </td>
        <td>
            SSH server keys. If this volume is not
            mounted, a new key will be generated on
            each container startup
        </td>
    </tr>
</table>
<h2 id="configuring-ssh-access"><a class="header" href="#configuring-ssh-access">Configuring SSH access</a></h2>
<p>Josh supports SSH access (just pull without pushing, for now).
To use SSH, you need to add the following lines to your <code>~/.ssh/config</code>:</p>
<pre><code>Host your-josh-instance.com
    ForwardAgent yes
    PreferredAuthentications publickey
</code></pre>
<p>Alternatively, you can pass those options via <code>GIT_SSH_COMMAND</code>:</p>
<pre><code>GIT_SSH_COMMAND=&quot;ssh -o PreferredAuthentications=publickey -o ForwardAgent=yes&quot; git clone ssh://git@your-josh-instance.com/...
</code></pre>
<p>In other words, you need to ensure SSH agent forwarding is enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="josh-filter"><a class="header" href="#josh-filter">josh-filter</a></h1>
<p>Command to rewrite history using <code>josh</code> filter specs.
By default it will use <code>HEAD</code> as input and update <code>FILTERED_HEAD</code> with the filtered
history, taking a filter specification as argument.
(Note that input and output are swapped with <code>--reverse</code>.)</p>
<p>It can be installed with the following Cargo command, assuming Rust is installed:</p>
<pre><code class="language-shell">cargo install josh-filter --git https://github.com/josh-project/josh.git
</code></pre>
<h1 id="git-sync"><a class="header" href="#git-sync">git-sync</a></h1>
<p>A utility to make working with server side rewritten commits easier.
Those commits frequently get produced when making changes to <code>workspace.josh</code> files.</p>
<p>The command is available <a href="https://raw.githubusercontent.com/josh-project/josh/master/scripts/git-sync">in the script
directory</a>.
It should be put downloaded and added to the <code>PATH</code>.
It can then be used as a drop-in replacement for <code>git push</code>.
It enables the server to <em>return</em> commits back to the client after a push. This is done by parsing
the messages sent back by the server for announcements of rewritten commits and then fetching
those to update the local references.
In case of a normal git server that does not rewrite anything, <code>git sync</code> will do exactly the
same as <code>git push</code>, also accepting the same arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphql-api-1"><a class="header" href="#graphql-api-1">GraphQL API</a></h1>
<p>Josh implements a GraphQL API to query the content of repositories without a need to clone
them via a git client.</p>
<p>The API is exposed at:</p>
<pre><code>http://hostname/~/graphql/name_of_repo.git
</code></pre>
<p>To explore the API and generated documentation, an interactive GraphQL shell can be found at:</p>
<pre><code>http://hostname/~/graphiql/name_of_repo.git
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Currently the Josh project mainly uses integration tests for it's verification, so make sure you will be able
to run and check them.</p>
<p>The following sections will describe how to run the different kind's of tests used for the verification
of the Josh project.</p>
<h2 id="unittests--doctests"><a class="header" href="#unittests--doctests">UnitTests &amp; DocTests</a></h2>
<pre><code class="language-shell">cargo test --all
</code></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<h3 id="1-setup-the-test-environment"><a class="header" href="#1-setup-the-test-environment">1. Setup the test environment</a></h3>
<p>Due to the fact that the integration tests need additional tools and a more complex
environment and due to the fact that the integration test are done using <a href="https://pypi.org/project/cram/">cram</a>.
you will need to crate an extra environment to run these tests. To simplify the
setup of the integration testing we have set up a <a href="https://nixos.org/manual/nix/stable/#chap-installation">Nix Shell</a> environment which
you can start by using the following command if you have installed the <a href="https://nixos.org/manual/nix/stable/#chap-installation">Nix Shell</a>.</p>
<p><strong>Attention:</strong>
Currently it is still necessary to install the following tools in your host system.</p>
<ul>
<li>curl</li>
<li>hyper_cgi
<pre><code class="language-shell">cargo install hyper_cgi --features=test-server
</code></pre>
</li>
</ul>
<h4 id="setup-the-nix-shell"><a class="header" href="#setup-the-nix-shell">Setup the Nix Shell</a></h4>
<p><strong>Attention:</strong>
When running this command the first time, this command will take quite a bit to
finish. You also will need internet access while executing this command.
Depending on performance of your connection the command will take more or less time.</p>
<pre><code class="language-shell">nix-shell shell.nix
</code></pre>
<p>Once the command is finished you will be prompted with the nix-shell which will
provide the needed shell environment to execute the integration tests.</p>
<h3 id="2-verify-you-have-built-all-necessary-binaries"><a class="header" href="#2-verify-you-have-built-all-necessary-binaries">2. Verify you have built all necessary binaries</a></h3>
<pre><code class="language-shell">cargo build
cargo build --bin josh-filter
cargo build --manifest-path josh-proxy/Cargo.toml
cargo build --manifest-path josh-ui/Cargo.toml
</code></pre>
<h3 id="3-setup-static-files-for-the-josh-ui"><a class="header" href="#3-setup-static-files-for-the-josh-ui">3. Setup static files for the josh-ui</a></h3>
<pre><code class="language-shell">cd josh-ui 
trunk build 
cd ..
</code></pre>
<h3 id="4-run-the-integration-tests"><a class="header" href="#4-run-the-integration-tests">4. Run the integration tests</a></h3>
<p><strong>Attention:</strong> Be aware that all tests except the once in experimental should be green.</p>
<pre><code class="language-shell">sh run-tests.sh -v tests/
</code></pre>
<h2 id="ui-tests"><a class="header" href="#ui-tests">UI Tests</a></h2>
<p>TBD: Currently disabled, stabilize, enable and document process.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dev-tools"><a class="header" href="#dev-tools">Dev-Tools</a></h1>
<ul>
<li><a href="https://nixos.org/manual/nix/unstable/command-ref/nix-shell.html">Nix Shell</a></li>
<li><a href="https://rustup.rs/">Rust</a></li>
<li><a href="https://rustup.rs/">Cargo</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
